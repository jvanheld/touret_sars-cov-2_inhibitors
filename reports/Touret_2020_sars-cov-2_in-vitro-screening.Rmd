---
title: "Statistical analysis of *in vitro* screening for inhibitors of viral infection "
author: "Touret et al. (2020). "
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: hide
    fig_caption: yes
    highlight: zenburn
    self_contained: no
    theme: cerulean
    toc: yes
    toc_depth: 3
    toc_float: yes
  ioslides_presentation:
    colortheme: dolphin
    fig_caption: yes
    fig_height: 6
    fig_width: 7
    fonttheme: structurebold
    highlight: tango
    smaller: yes
    toc: yes
    widescreen: yes
  beamer_presentation:
    colortheme: dolphin
    fig_caption: yes
    fig_height: 6
    fig_width: 7
    fonttheme: structurebold
    highlight: tango
    incremental: no
    keep_tex: no
    slide_level: 2
    theme: Montpellier
    toc: yes
  word_document:
    toc: yes
    toc_depth: '3'
  slidy_presentation:
    fig_caption: yes
    fig_height: 6
    fig_width: 7
    highlight: tango
    incremental: no
    keep_md: yes
    smaller: yes
    theme: cerulean
    toc: yes
    widescreen: yes
  pdf_document:
    fig_caption: yes
    highlight: zenburn
    toc: yes
    toc_depth: 3
font-import: http://fonts.googleapis.com/css?family=Risque
subtitle:  Exploration of the results
font-family: Garamond
transition: linear
---

```{r libraries, echo=FALSE, results=FALSE, warning=FALSE, message=FALSE}
#### Install required packages ####
required.packages <- c("xlsx", "readxl", "knitr", "fitdistrplus")

for (pkg in required.packages) {
  if (!require(pkg, character.only = TRUE)) {
    message("Installing package ", pkg)
    install.packages(pkg, dependencies = TRUE)
  }
  require(pkg, character.only = TRUE)
}
```



```{r knitr_settings, include=FALSE, echo=FALSE, eval=TRUE}
library(knitr)
options(width = 300)
knitr::opts_chunk$set(
  fig.width = 7, fig.height = 5, 
  fig.path = 'figures/touret_sars-cov-2_inhibitors',
  fig.align = "center", 
  size = "tiny", 
  echo = TRUE, eval = TRUE, 
  warning = FALSE, message = FALSE, 
  results = TRUE, comment = "")
# knitr::asis_output("\\footnotesize")


## Store original graphic parameters to restore them after chunks
par.ori <- par(no.readonly = TRUE)

```


## Supplementary data tables

```{r parameters}
#### Directories ####
message("Directories and files")

dir <- c(data = "../data", 
         results = "../results",
         figures = "figures")
dir.create(dir["results"], showWarnings = FALSE, recursive = TRUE)

## Data file
supTableFile <- file.path(dir["data"], "suppl-table_Touret-2020.xlsx")


```


```{r load_table}
#### Load data from Excel workbook ####
message("Loading data from excel workbook.")
supTable <- read.xlsx(file = supTableFile, sheetIndex = 1)
#supTable <- read_xlsx(path = supTableFile, sheet = 1, col_names = TRUE)
# dim(supTable)
# View(supTable)
# names(supTable)

colNames <- colnames(supTable)
colNames[1] <- "ID"
colnames(supTable) <- colNames

## Suppress the last row (NA)
supTable <- supTable[!is.na(supTable$ID), ]
# dim(supTable)

## Assign row names for convenience
# View(supTable)


## Extract plate number
supTable$plateNumber <- as.numeric(substr(supTable[, 1], start = 1, stop = 2))
# table(supTable$plateNumber)
plateNumbers <- unique(supTable$plateNumber)

## Assign a color to each molecule according to its plate number
plateColor <- rainbow(n = length(plateNumbers))
names(plateColor) <- unique(supTable$plateNumber)

supTable$color <- plateColor[supTable$plateNumber]
message("\tLoaded main table with ", nrow(supTable), " rows ")
```

The supplementary table downloaded from bioRxiv contains `r nrow(supTable)` molecules. 


## Raw data

```{r raw_data}
#### Load raw data ####
message("Loading raw data")
nbPlates <- 19
rowsPerPlate <- 8
columnsPerPlate <- 12

dataPerPlate <- list()

## Control 1: uninfected cells
cellControl <- data.frame(matrix(ncol = 8, nrow = nbPlates))
colnames(cellControl) <- LETTERS[1:rowsPerPlate]

## Control 2: untreated infected cells
virusControl <- data.frame(matrix(ncol = 6, nrow = nbPlates))
colnames(virusControl) <- LETTERS[3:rowsPerPlate]

## Prepare a table to store the raw data
inhibTable <- data.frame(matrix(ncol = 8, nrow = nbPlates*rowsPerPlate * columnsPerPlate))
colnames(inhibTable) <- c("ID", 
                          "Plate", 
                          "Row", 
                          "Column", 
                          "viability", 
                          "cellControl", 
                          "virusControl",
                          "chemicalName")

i <- 2 ## for quick test
for (i in 1:nbPlates) {
  message("\tLoading data from plate ", i)
  sheetName <- paste0("Plate", i)
  
  ## Raw measures
  # rawMeasures <- read.xlsx(file = supTableFile, 
  #                          sheetName = sheetName, 
  #                          rowIndex = 30:37,
  #                          colIndex = 2:13, header = FALSE)
  rawMeasures <- read_xlsx(path = supTableFile, col_names = FALSE, 
                           sheet = sheetName, 
                           range = "B30:M37", progress = FALSE)
  rawMeasures <- as.data.frame(rawMeasures)
  rownames(rawMeasures) <- LETTERS[1:nrow(rawMeasures)]
  colnames(rawMeasures) <- 1:ncol(rawMeasures)
  # dim(rawMeasures)
  # View(rawMeasures)

  ## Extract control values
  cellControl[i, ] <- as.vector(rawMeasures[,1])
  virusControl[i, ] <- as.vector(rawMeasures[3:8,12])
  plateVC <- mean(unlist(virusControl[i, ]))
  plateCC <- mean(unlist(cellControl[i, ]))

  ## Extract all values
  r <- 1
  for (r in 1:rowsPerPlate) {
    currentRowName <- LETTERS[r]
    currentValues <- unlist(rawMeasures[currentRowName,])
    id <- paste0(sprintf("%02d",i),
                 currentRowName, 
                 sprintf("%02d",1:columnsPerPlate))
    
    ## Compute the start index for the data table
    startIndex <- (i - 1) * (rowsPerPlate * columnsPerPlate) + (r - 1) * columnsPerPlate + 1
    # message(cat("\t\tIDs\t",  startIndex, id))
    indices <- startIndex:(startIndex + columnsPerPlate - 1)
    # length(indices)
    inhibTable[indices, "ID"] <- id
    inhibTable[indices, "Plate"] <- i
    inhibTable[indices, "Row"] <- currentRowName
    inhibTable[indices, "Column"] <- 1:columnsPerPlate
    inhibTable[indices, "viability"] <- currentValues
    inhibTable[indices, "virusControl"] <- plateVC
    inhibTable[indices, "cellControl"] <- plateCC
  }
  
  dataPerPlate[[i]] <- list()
  dataPerPlate[[i]][["rawMeasures"]] <- rawMeasures
}

# dim(inhibTable)
# names(inhibTable)
# View(inhibTable)
# View(dataPerPlate)
# View(dataPerPlate[[1]][["rawMeasures"]])
# table(inhibTable$Row, inhibTable$Column) ## Check that there are 19 entries for each plate position

## Use the plate well ID as rowname
rownames(inhibTable) <- inhibTable$ID

## Check consistency between IDs in supplementary Touret Table 1
##  and those created here
touretIDs <- unlist(supTable$ID)
# length(touretIDs)
inhibIDs <- inhibTable$ID
# length(inhibIDs)
setdiff(touretIDs, inhibIDs)
setdiff(inhibIDs, touretIDs)

## Retrieve the molecule names from Table 1 of the bioRxiv workbook

length(chemicalName)
inhibTable$chemicalName <- NA
inhibTable[inhibTable$ID %in% touretIDs, "chemicalName"] <- 
  as.vector(supTable$Chemical.name)

## Cell control: uninfected cells
cellControlIndices <- inhibTable$Column == 1
inhibTable[cellControlIndices, "chemicalName"] <- "uninfected"

## Virus control: infected cells, no treatment
virusControlIndices <- (inhibTable$Column == 12) & (inhibTable$Row %in% LETTERS[3:8])
# table(virusControlIndices)
inhibTable[virusControlIndices, "chemicalName"] <- "infected no treatment"
table(inhibTable$chemicalName)

## All the other ones are treated with a given molecule
inhibTable$type <- NA
inhibTable[cellControlIndices, "type"] <- "cellCtl"
inhibTable[virusControlIndices, "type"] <- "virusCtl"
inhibTable[!(virusControlIndices | cellControlIndices), "type"] <- "treated"

```


The raw data contains `r nbPlates` plates with `r rowsPerPlate` rows (indiced  `r LETTERS[1]` to `r LETTERS[columnsPerPlate]`) and `r columnsPerPlate` columns (indiced from 1 to `r columnsPerPlate`. )

The raw data consists of viability measurements in cell cultures. 


### Distribution of raw viability measurements

```{r raw_viab_distrib, fig.width=7, fig.height=10, out.width="60%", fig.cap="Distributions of the raw viability measures. "}
#### Distribution of raw measurements ####

xmin <- floor(min(inhibTable$viability)/100) * 100
xmax <- ceiling(max(inhibTable$viability)/100) * 100
breaks = seq(from = xmin, to = xmax, by = 100)

par(mfrow = c(3, 1))
par(mar = c(2,5,3,1))
hist(inhibTable$viability, 
     main = "Raw viability measures",
     xlab = "Viability",
     ylab = "Number of measures",
     las = 1, 
     breaks = breaks, col = "grey", border = "grey")

hist(inhibTable[cellControlIndices, "viability"], 
     main = "Cell control (uninfected)",
     xlab = "Viability",
     ylab = "Number of measures",
     las = 1, 
     breaks = breaks, col = "palegreen", border = "palegreen")

hist(inhibTable[virusControlIndices, "viability"], 
     main = "Virus control (infected, no treatment)",
     xlab = "Viability",
     ylab = "Number of measures",
     las = 1, 
     breaks = breaks, col = "orange", border = "orange")

par(par.ori)

```

The distribution is strongly asymmetrical, and seems bi- or multi-modal. 
This probably reflects the presence of a mixture of distribution, comprising

- controls: uninfected cells


## Inhibitiion index

### Descriptive stats

```{r inhib_index_stat}
ii <- supTable$Inhibition.Index
iiStat <- list(
  mean = mean(ii),
  sd = sd(ii),
  var = var(ii),
  min = min(ii),
  Q1 = as.vector(quantile(ii, probs = 0.25)),
  median = median(ii),
  Q3 = as.vector(quantile(ii, probs = 0.75)),
  max = max(ii)
)

kable(t(as.data.frame.list(iiStat)), col.names = "Stat")

```


### Distribution

The distribution of inhibition index values is trongly asymmetrical. The mode is much lower than the mean and the median (robust estimator of central tendency). A normal fit will tuhs give a poor estimate of the p-values. 
```{r inhib_index_distribution, fig.width=7, fig.height=5, out.width="60%",  fig.cap="Distribution of the inhibition index"}

hist(supTable$Inhibition.Index, breaks = 100, col = "grey", border = "grey")
abline(v = iiStat$mean, col = "blue")
abline(v = iiStat$median, col = "darkgreen")

legend("topright", legend = c("mean", "median"),
       col = c("blue", "darkgreen"),
       lwd = 2)

```






## Normalisation

### Log transform

A classical method for normalisation is to take the log of the values. We first had to shift the data in order for all of them to take positive values. 


```{r ii_normalisation}

# fit.gamma <- fitdist(data = ii - iiStat$min + 1, distr = "gamma", method = "mge")
# summary(fit.gamma)
# 
# plot(fit.gamma)

#### Compute a normalised distribution from inhibition indices ####
iiPositive <- ii - iiStat$min + 1 ## shift the distrib to achieve non-negative numbers
logII <- log(iiPositive)

logIIStat <- list(
  mean = mean(logII),
  sd = sd(logII),
  var = var(logII),
  min = min(logII),
  Q1 = as.vector(quantile(logII, probs = 0.25)),
  median = median(logII),
  Q3 = as.vector(quantile(logII, probs = 0.75)),
  max = max(logII)
)

kable(t(as.data.frame.list(logIIStat)), col.names = "Stat", caption = "Parameters of the log-normalised inhibition index distribution")

```


However, even after log transformation the distribution remains highly asymmetrical, with a mode much smaller than the median and mean. 

```{r logII_distrib, fig.width=7, fig.height=5, out.width="60%", fig.cap="Distribution of the inhibition index"}
#### Histogram of log-normalised values ####
hist(logII, breaks = 100, col = "grey", border = "grey")
abline(v = mean(logII), col = "blue")
abline(v = median(logII), col = "darkgreen")

legend("topright", legend = c("mean", "median"),
       col = c("blue", "darkgreen"),
       lwd = 2)


```


## Evidence of a plate bias

### Ranked values

We plot the inhibition index values ordered by plate and position number (top) or ranked by decreasing value (bottom). In both cases, the color denotes the plate number. 


```{r inhib_index_ranked, fig.width=7, fig.height=10, out.width="60%", fig.cap="Values of the inhibition index for all the tested molecules. Molecules are colored according to the plate number. "}
par(mfrow = c(2,1))
plot(ii,
     panel.first = grid(),
     main = "Inhibition index values",
     xlab = "Molecules (ranked by inhibition index)",
     ylab = "Inhibition index",
     col = supTable$color,
     cex = 0.5,
     xlim = c(0, length(ii)*1.05)
     )
legend("topright", 
       legend = names(plateColor), 
       col = plateColor, pch = 1, 
       cex = 0.7)

sortedTable <- supTable[order(supTable$Inhibition.Index, decreasing = TRUE), ]
plot(sortedTable$Inhibition.Index,
     panel.first = grid(),
     main = "Ranked inhibition index values",
     xlab = "Molecules (ranked by inhibition index)",
     ylab = "Inhibition index",
     col = sortedTable$color,
     cex = 0.5,
     xlim = c(0, length(ii)*1.05)
     )
legend("topright", 
       legend = names(plateColor), 
       col = plateColor, pch = 1, 
       cex = 0.7)
par(mfrow = c(1, 1))

```


The molecule-wised colored plots of inhibition index suggest a plate-wise effect. 

## Plate-wise normalisation

We perform a plate-wise normalisation using robust estimators, in order to avoid the effect of outliers (in this case, the suspected outliers are the molecules having an actual inhibitory effect).

To this purpose, we use:
- plate-wise median to estimate the mean
- plate-wise standardised inter-quantile range (IQR) to estimate the standard deviation

```{r plate_wise_stat}
#### Copute plate-wise statistics ####
plateStat <- data.frame(
  plate = plateNumbers,
  mean = as.vector(by(data = supTable$Inhibition.Index, INDICES = supTable$plateNumber, FUN = mean)),
  sd = as.vector(by(data = supTable$Inhibition.Index, INDICES = supTable$plateNumber, FUN = sd)),
  median = as.vector(by(data = supTable$Inhibition.Index, INDICES = supTable$plateNumber, FUN = median)),
  min = as.vector(by(data = supTable$Inhibition.Index, INDICES = supTable$plateNumber, FUN = min)),
  max = as.vector(by(data = supTable$Inhibition.Index, INDICES = supTable$plateNumber, FUN = max)),
  IQR = as.vector(by(data = supTable$Inhibition.Index, INDICES = supTable$plateNumber, FUN = IQR))
)
rownames(plateStat) <- plateStat$plate

kable(plateStat, caption = "Plate-wise statistics")

```

```{r plate_wise_normalisation}

## Centering: substract the median
## Scaling: divide by IQR
## Standardise: multiply by IQR of the normal distribution
normII <- (supTable$Inhibition.Index - plateStat[supTable$plateNumber, "median"]) / plateStat[supTable$plateNumber, "IQR"]
# IQR(normII)
# IQR(rnorm(n = 1000000))

normIQR <- qnorm(p = 0.75) - qnorm(p = 0.25)
normII <- normII * normIQR
# sd(normII)
# IQR(normII)

supTable$normInhibIndex <- normII

```



```{r normIIStat}
### Descriptive statistics on the normalised Inhibition Index ####
normIIStat <- list(
  mean = mean(normII),
  sd = sd(normII),
  IQR = IQR(normII),
  var = var(normII),
  min = min(normII),
  Q1 = as.vector(quantile(normII, probs = 0.25)),
  median = median(normII),
  Q3 = as.vector(quantile(normII, probs = 0.75)),
  max = max(normII)
)

kable(t(as.data.frame.list(normIIStat)), col.names = "Stat", caption = "Statistics of the plate-wise normalised inhibition index")

```


The histogram of plate-wise normalised values shows a clear improvement : the median is much closer to the mode than with the raw or log-transformed II values.

```{r normII_distrib, fig.width=7, fig.height=5, out.width="60%", fig.cap="Distribution of the plate-wise normalised inhibition index"}

hist(normII, breaks = 100, col = "grey", border = "grey")
abline(v = mean(normII), col = "blue")
abline(v = median(normII), col = "darkgreen")

legend("topright", legend = c("mean", "median"),
       col = c("blue", "darkgreen"),
       lwd = 2)

```

### Normalised II plots

The plot of normalised II values (top panel) clearly shows that the plate-wise normalisation suppressed the background bias. 


```{r normII_ranked, fig.width=7, fig.height=10, out.width="60%", fig.cap="Values of the plate-wise normalised inhibition index for all the tested molecules. Molecules are colored according to the plate number. "}
par(mfrow = c(2,1))
plot(normII,
     panel.first = grid(),
     main = "Inhibition index values",
     xlab = "Molecules (ranked by inhibition index)",
     ylab = "Inhibition index",
     col = supTable$color,
     cex = 0.5,
     xlim = c(0, length(normII)*1.05)
     )
legend("topright", 
       legend = names(plateColor), 
       col = plateColor, pch = 1, 
       cex = 0.7)

# names(supTable)
normIIrank <- order(supTable$normInhibIndex, decreasing = TRUE)
plot(supTable[normIIrank, "normInhibIndex"],
     panel.first = grid(),
     main = "Ranked inhibition index values",
     xlab = "Molecules (ranked by inhibition index)",
     ylab = "Inhibition index",
     col = supTable[normIIrank, "color"],
     cex = 0.5,
     xlim = c(0, length(normII)*1.05)
     )
legend("topright", 
       legend = names(plateColor), 
       col = plateColor, pch = 1, 
       cex = 0.4)
par(mfrow = c(1,1))

```




## P-value computation

We compute the p-value as the upper tail of the normal distribution (rigth-side test) in order to detect significantly high values of the plate-wise normalised index.

```{r normIIpval}
#### Compute P-value for the inhibition index ####
supTable$p.value <- pnorm(normII, mean = 0, sd = 1, lower.tail = FALSE)
supTable$log10Pval <- log10(supTable$p.value)
supTable$e.value <- supTable$p.value * length(normII)
supTable$padj <- p.adjust(supTable$p.value, method = "fdr")
supTable$log10Padj <- log10(supTable$padj)
```

```{r pval_histogram, fig.width=7, fig.height=5, out.width="60%", fig.cap="Histogram of the nominal (unadjusted) p-values derived from the plate-wise normalised inhibition index. "}
hist(supTable$p.value, breaks = 20, 
     col = "grey",
     main = "P-value histogram after plate-wise normalisation",
     xlab = "Nominal P-value (unadjusted)",
     ylab = "Frequency")
```



```{r volcano_plot, fig.width=7, fig.height=7, out.width="60%", fig.cap="Volcano plot. "}
#### Volcano plot ####

plot(x = supTable$normInhibIndex,
     y = -supTable$log10Padj, 
     col = supTable$color,
     main = "Volcano plot",
     xlab = "Normalised inhibition index",
     ylab = "Significance = -log10(Padj)")
grid()

```


## Selection of candidate molecules

```{r candidated}

#### Select significant normalised II values ####
alpha <- 0.05
# table(supTable$padj < alpha)
selected <- subset(supTable, supTable$padj < alpha)

## Sort by decreasing adjusted p-value
selected <- selected[order(selected$padj, decreasing = FALSE), ]
# kable(names(selected), row.names=TRUE)

## Print selected molecules
kable(selected[ , c(1:3, 5:7, 10, 12, 15)], 
      row.names = FALSE,
      digits = 4,
      caption = "Candidate moecules sorted by significance after plate-wise normalisation. ")


```



## Conclusions

I strongly recommend to use the plate-wise normalised inhibition index in order to select the candidate molecules. 

With an adjusted p-value of `r alpha`,  `r nrow(selected)` molecules are declared significant and could be considered as candidate for further characterisation. 




## Experimental design

- la manip consiste à faire un test colorimétrique

    - sur certains puits tout est négatif, sur d'autres tout est positiv

- mortalité des cellules

    - infectées non-traitées ("virus control")
    - 6 puits

- viabilité des cellules -> 100%

    - cellules non-infectées et non-traitées ("cell control")
    - 8 puits

- duplicat de traitement à l'arabidol 10µM

    - seuil par plaque
    - contrôle interne de la protection des cellules contre la mortalité viro-induite


- Valeurs de départ

    - mort cellulaire (moyenne sur 6 puits)
    - viabilité (moyenne sur 8 puits)
    - valeur du composé (monoplicat) : même concentration de 10µM par composé

Indice d'inhibition: 

$$v = A / (D + A)$$



$$II = $$

On cherche des molécules inhibitrices avec l'EC50 aux alentours de 5µM -> la concentration standard de 10µM on espère se trouver au début du plateau. 

## A faire

- comparer les listes de composés avant / après normalisation par plaque
- boxplot ou violin par plaque avant / après
- standardisation des valeurs de viabilité par la médiane
- distribution de valeurs plaque par plaque --> vérifier si certaines plaques ont l'air d'avoir plus de 20 cibles (percentile75)


- Contrôles intra-plaques
    - utiliser médiane plutôt que moyenne ?

- Valeurs négatives: 

    - fluctuations expérimentales ?
    - mortalité induite par le virus + la molécule ?
    
- Marquer sur les graphiques les valeurs de l'arbidol (contrôle interne en duplicat)


- boxplot des contrôles par plaque: 

    - cell viability
    - viral 


