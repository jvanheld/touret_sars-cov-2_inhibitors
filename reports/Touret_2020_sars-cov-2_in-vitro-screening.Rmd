---
title: "Statistical analysis of *in vitro* screening for inhibitors of viral infection "
author: "Touret et al. (2020). "
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: hide
    fig_caption: yes
    highlight: zenburn
    self_contained: no
    theme: cerulean
    toc: yes
    toc_depth: 3
    toc_float: yes
  ioslides_presentation:
    colortheme: dolphin
    fig_caption: yes
    fig_height: 6
    fig_width: 7
    fonttheme: structurebold
    highlight: tango
    smaller: yes
    toc: yes
    widescreen: yes
  beamer_presentation:
    colortheme: dolphin
    fig_caption: yes
    fig_height: 6
    fig_width: 7
    fonttheme: structurebold
    highlight: tango
    incremental: no
    keep_tex: no
    slide_level: 2
    theme: Montpellier
    toc: yes
  word_document:
    toc: yes
    toc_depth: '3'
  slidy_presentation:
    fig_caption: yes
    fig_height: 6
    fig_width: 7
    highlight: tango
    incremental: no
    keep_md: yes
    smaller: yes
    theme: cerulean
    toc: yes
    widescreen: yes
  pdf_document:
    fig_caption: yes
    highlight: zenburn
    toc: yes
    toc_depth: 3
font-import: http://fonts.googleapis.com/css?family=Risque
subtitle:  Exploration of the results
font-family: Garamond
transition: linear
---

```{r libraries, echo=FALSE, results=FALSE, warning=FALSE, message=FALSE}
#### Install required packages ####
required.packages <- c("xlsx", "readxl", "knitr", "fitdistrplus", "vioplot")

for (pkg in required.packages) {
  if (!require(pkg, character.only = TRUE)) {
    message("Installing package ", pkg)
    install.packages(pkg, dependencies = TRUE)
  }
  require(pkg, character.only = TRUE)
}
```



```{r knitr_settings, include=FALSE, echo=FALSE, eval=TRUE}
library(knitr)
options(width = 300)
knitr::opts_chunk$set(
  fig.width = 7, fig.height = 5, 
  fig.path = 'figures/touret_sars-cov-2_inhibitors',
  fig.align = "center", 
  size = "tiny", 
  echo = TRUE, eval = TRUE, 
  warning = FALSE, message = FALSE, 
  results = TRUE, comment = "")
# knitr::asis_output("\\footnotesize")


## Store original graphic parameters to restore them after chunks
par.ori <- par(no.readonly = TRUE)

```

# Introduction

# Data

## Supplementary data tables

```{r parameters}
#### Directories ####
message("Directories and files")

dir <- c(data = "../data", 
         results = "../results",
         figures = "figures")
dir.create(dir["results"], showWarnings = FALSE, recursive = TRUE)

## Data file
supTableFile <- file.path(dir["data"], "suppl-table_Touret-2020.xlsx")


```


```{r load_table}
#### Load data from Excel workbook ####
message("Loading data from excel workbook.")
supTable <- read.xlsx(file = supTableFile, sheetIndex = 1)
#supTable <- read_xlsx(path = supTableFile, sheet = 1, col_names = TRUE)
# dim(supTable)
# View(supTable)
# names(supTable)

colNames <- colnames(supTable)
colNames[1] <- "ID"
colnames(supTable) <- colNames

## Suppress the last row (NA)
supTable <- supTable[!is.na(supTable$ID), ]
# dim(supTable)

## Assign row names for convenience
# View(supTable)


## Extract plate number
supTable$plateNumber <- as.numeric(substr(supTable[, 1], start = 1, stop = 2))
# table(supTable$plateNumber)
plateNumbers <- unique(supTable$plateNumber)

## Assign a color to each molecule according to its plate number
plateColor <- rainbow(n = length(plateNumbers))
names(plateColor) <- unique(supTable$plateNumber)

supTable$color <- plateColor[supTable$plateNumber]
message("\tLoaded main table with ", nrow(supTable), " rows ")
```

The supplementary table downloaded from bioRxiv contains `r nrow(supTable)` molecules. 


# Raw viability measurements

```{r raw_data}
#### Load raw data ####
message("Loading raw data")
nbPlates <- 19
rowsPerPlate <- 8
columnsPerPlate <- 12

dataPerPlate <- list()

## Control 1: uninfected cells
cellControl <- data.frame(matrix(ncol = 8, nrow = nbPlates))
colnames(cellControl) <- LETTERS[1:rowsPerPlate]

## Control 2: untreated infected cells
virusControl <- data.frame(matrix(ncol = 6, nrow = nbPlates))
colnames(virusControl) <- LETTERS[3:rowsPerPlate]

## Prepare a table to store the raw data
inhibTable <- data.frame(matrix(ncol = 8, nrow = nbPlates*rowsPerPlate * columnsPerPlate))
colnames(inhibTable) <- c("ID", 
                          "Plate", 
                          "Row", 
                          "Column", 
                          "viability", 
                          "cellControl", 
                          "virusControl",
                          "chemicalName")

i <- 2 ## for quick test
for (i in 1:nbPlates) {
  message("\tLoading data from plate ", i)
  sheetName <- paste0("Plate", i)
  
  ## Raw measures
  # rawMeasures <- read.xlsx(file = supTableFile, 
  #                          sheetName = sheetName, 
  #                          rowIndex = 30:37,
  #                          colIndex = 2:13, header = FALSE)
  rawMeasures <- read_xlsx(path = supTableFile, col_names = FALSE, 
                           sheet = sheetName, 
                           range = "B30:M37", progress = FALSE)
  rawMeasures <- as.data.frame(rawMeasures)
  rownames(rawMeasures) <- LETTERS[1:nrow(rawMeasures)]
  colnames(rawMeasures) <- 1:ncol(rawMeasures)
  # dim(rawMeasures)
  # View(rawMeasures)

  ## Extract control values
  cellControl[i, ] <- as.vector(rawMeasures[,1])
  virusControl[i, ] <- as.vector(rawMeasures[3:8,12])
  plateVC <- mean(unlist(virusControl[i, ]))
  plateCC <- mean(unlist(cellControl[i, ]))

  ## Extract all values
  r <- 1
  for (r in 1:rowsPerPlate) {
    currentRowName <- LETTERS[r]
    currentValues <- unlist(rawMeasures[currentRowName,])
    id <- paste0(sprintf("%02d",i),
                 currentRowName, 
                 sprintf("%02d",1:columnsPerPlate))
    
    ## Compute the start index for the data table
    startIndex <- (i - 1) * (rowsPerPlate * columnsPerPlate) + (r - 1) * columnsPerPlate + 1
    # message(cat("\t\tIDs\t",  startIndex, id))
    indices <- startIndex:(startIndex + columnsPerPlate - 1)
    # length(indices)
    inhibTable[indices, "ID"] <- id
    inhibTable[indices, "Plate"] <- i
    inhibTable[indices, "Row"] <- currentRowName
    inhibTable[indices, "Column"] <- 1:columnsPerPlate
    inhibTable[indices, "viability"] <- currentValues
    inhibTable[indices, "virusControl"] <- plateVC
    inhibTable[indices, "cellControl"] <- plateCC
  }
  
  dataPerPlate[[i]] <- list()
  dataPerPlate[[i]][["rawMeasures"]] <- rawMeasures
}

# dim(inhibTable)
# names(inhibTable)
# View(inhibTable)
# View(dataPerPlate)
# View(dataPerPlate[[1]][["rawMeasures"]])
# table(inhibTable$Row, inhibTable$Column) ## Check that there are 19 entries for each plate position

## Use the plate well ID as rowname
rownames(inhibTable) <- inhibTable$ID

## Check consistency between IDs in supplementary Touret Table 1
##  and those created here
touretIDs <- unlist(supTable$ID)
# length(touretIDs)
inhibIDs <- inhibTable$ID
# length(inhibIDs)

## Retrieve the molecule names from Table 1 of the bioRxiv workbook
inhibTable$chemicalName <- NA
inhibTable[inhibTable$ID %in% touretIDs, "chemicalName"] <- 
  as.vector(supTable$Chemical.name)

## Cell control: uninfected cells
cellControlIndices <- inhibTable$Column == 1
inhibTable[cellControlIndices, "chemicalName"] <- "uninfected"

## Virus control: infected cells, no treatment
virusControlIndices <- (inhibTable$Column == 12) & (inhibTable$Row %in% LETTERS[3:8])
# table(virusControlIndices)
inhibTable[virusControlIndices, "chemicalName"] <- "infected no treatment"

## Define the treatment type
wellType <- NA
wellType[cellControlIndices] <- "cellCtl"
wellType[virusControlIndices] <- "virusCtl"

## All the other ones are treated with a given molecule
wellType[!(virusControlIndices | cellControlIndices)] <- "treated"

inhibTable[, "wellType"] <- wellType
kable(t(table(inhibTable$wellType)), caption = "Well types. cellCtl: no infection; virusCtl: infection without treatment; treated: inhected and treated with one molecule", )

```


The raw data contains `r nbPlates` plates with `r rowsPerPlate` rows (indiced  `r LETTERS[1]` to `r LETTERS[rowsPerPlate]`) and `r columnsPerPlate` columns (indiced from 1 to `r columnsPerPlate`. )

The raw data consists of viability measurements in cell cultures. 


## Distribution of raw viability values

```{r raw_viab_distrib, fig.width=10, fig.height=7, out.width="80%", fig.cap="Distributions of the raw viability measures. Top: uninfected cells. Middle: infected cells without treatment. Bottom: infected cells treated with a specific molecule. "}

#### Distribution of raw measurements ####
classInterval <- 500
# xmin <- floor(min(inhibTable$viability)/classInterval) * classInterval
xmin <- 0 ## Intently start the scale at0 to show the remnant viability
xmax <- ceiling(max(inhibTable$viability)/classInterval) * classInterval
breaks = seq(from = xmin, to = xmax, by = classInterval)
# range(inhibTable$viability)

par(mfrow = c(3, 1))
par(mar = c(2,5,3,1))
hist(inhibTable[wellType == "cellCtl", "viability"], 
     main = "Uninfected (cell control)",
     xlab = "Viability",
     ylab = "Number of plate wells",
     las = 1, 
     breaks = breaks, col = "palegreen", border = "palegreen")

hist(inhibTable[wellType == "virusCtl", "viability"], 
     main = "Infected, no treatment (virus control))",
     xlab = "Viability",
     ylab = "Number of plate wells",
     las = 1, 
     breaks = breaks, col = "orange", border = "orange")

hist(inhibTable[wellType == "treated", "viability"], 
     main = "Treated cells",
     xlab = "Viability",
     ylab = "Number of plate wells",
     las = 1, 
     breaks = breaks, col = "#AACCFF", border = "#AACCFF")


par(par.ori)

```

- ***Cell control***. 

    - The top panel (green) shows the distribution of viability measurements in controls cultures, where the cells were neither infected by the virus nor treated with a drug. 
    - Each plate contains 8 wells with uninfected cells (total = `r sum(wellType == "cellCtl")`). 

- ***Virus control***. 

    - The middle panel (orange) shows the distribution of viability measurements in infected cells without drug treatment
    - The virus control was performed on 6 wells per plate, total = `r sum(wellType == "virusCtl")`). 

- ***Treated cells***. 

    - The bottom distribution (pale blue) shows the viability values for cells infected and treated with a given drug. 
    
    - Note that each drug was tested on a single well (no replicates). Indeed, in order to face the COVID-19 emergency, the study attempted to test as fast as possible a wide range of molecules. This first screening was thus performed without replicates. This has to be taken into account for the normalisation, which should be done with no estimation of the variance for the individual drugs. 

    - The distribution is strongly asymmetrical, and seems bi- or multi-modal. This distribution can be considered as a mixture between different distributions;
    
        - all the drugs that have no inhibitory effect (and are thus expected to have a viability similar to the virus control);
        - various drugs that inhibit the action of the virus, each one with its specific level of inhibition. This probably corresponds to the widely dispersed values above the bulk of distribution (and above the virus control distribution) 


## Raw viability boxplots

```{r plate_colors}
#### Plate-wise colors ####

## Assign a color to each plate
## A trick: we alternate the colors of the rainbow in order 
## to see the contrast between successive plates
platePalette <- rainbow(n = length(plateNumbers))
plateColor <- vector(length = nbPlates)
oddIndices <- seq(1, nbPlates, 2)
evenIndices <- seq(2, nbPlates, 2)
plateColor[oddIndices] <- platePalette[1:length(oddIndices)]
plateColor[evenIndices] <- platePalette[(length(oddIndices) + 1):nbPlates]
names(plateColor) <- 1:nbPlates

## Assign a color to each result according to its plate
inhibTable$color <- plateColor[inhibTable$Plate]
# table(inhibTable$color) ## Check that each plate has 96 wells

```


```{r boxplots_per_plate_raw, fig.width=7, fig.height=10, out.width="80%", fig.cap="Distribution of raw viability values per plate"}
#### Boxplots per plate  ####

boxplot(viability ~ Plate + wellType, 
        main = "Raw viability per plate",
        data = inhibTable, 
        las = 1, col = plateColor, 
        xlab = "Viability (raw)", 
        cex.axis = 0.5, cex = 0.5,
        horizontal = TRUE
        )
abline(v = seq(from = 0, to = max(inhibTable$viability), by = 2000), col = "#EEEEEE", lty = "dashed")
abline(v = seq(from = 0, to = max(inhibTable$viability), by = 10000), col = "grey")

legend("topright", legend = names(plateColor), 
       title = "Plate", fill = plateColor, cex = 0.8)

par(par.ori)

```

The boxplot of the raw viability measurements highlights a plate effect, for the treated cells (middle barplots) but also for the untreated virus control (top boxplots) and uninfected cell control (bottom boxplots). 


- **Treated:**

    - The medians and interquartile ranges show strong variations between plates. 
    - In particular, plate 1 (in red) has a the smallest median and a remarkably compact interquartile range. There are many statistical outliers (empty circles) in this plate, which might correspond to the molecules having a significant inhibitory effect. 
    - In contrast, plates 11 to 15 show a high median and a wide dispersion of the viability measures, and there is not a single statistical outlier. 

- **Virus control**

    - Not surprisingly, untreated infected cells generally gave a very small viability, with small variations (very compact interquartile rectangles)
    - There is an obvious problem for plate 17, which shows a broad range of values, with a third quartile falling in the range of the uninfected cells. This suggests a problem with at least 2 of the 6 replicates (missed infection ?). Noticeably, the median falls in the same range as for the virus control of the other plates. 

- **Cell control**

    - The cell control performed as expected in all the plates, with high viability values.
    - Note however that the viability measurements show inter-plate variations, with median values ranging from ~37,000 to ~53,000. 

Importantly, there is a consistency between the inter-plate differences observed for virus control, treated cells and cell control, respectively. For example, plate 2 whose consistently higher value than the other plates for the three types of wells. This highlights the importances to perform a plate-wise standardisation. 
    
## Log2 viability boxplots

We performed a log2 transformation of the raw viability measures in order to normalise them. 

```{r boxplots_per_plate_log2, fig.width=7, fig.height=10, out.width="80%", fig.cap="Distribution of log2-transformed viability values per plate"}

#### Boxplots of log2_transformed viability per plate ####
inhibTable$log2V <- log2(inhibTable$viability)

## Box plot per plate and well type
boxplot(log2V ~ Plate + wellType, 
        main = "log2-transformed viability",
        data = inhibTable, 
        las = 1, col = plateColor, 
        xlab = "log2(V)", 
        cex.axis = 0.5, cex = 0.5,
        horizontal = TRUE)
abline(v = seq(from = 12, to = max(inhibTable$log2V), by = 0.2), col = "#EEEEEE", lty = "dashed")
abline(v = seq(from = 12, to = max(inhibTable$log2V), by = 1), col = "grey")
legend("topright", legend = names(plateColor), 
       title = "Plate", fill = plateColor, cex = 0.8)

par(par.ori)

```

The barplots of log2-transformed viability measures show yet another potential plate bias: in   plates 11 to 19, several molecules are associated to a much smaller viability than in any of the untreated cells. This might reflect a cytotoxic effect of the drug that would enforce the viral infection, but there is a priori no reason to expect such effects to be concentrated on the last plates. 

**Note: I (JvH) think this should be reported to the company that produces these plates**

# Plate-wise standardisation

## Two-points scaling: defining a relative viability ($v_r$)

Taking into account the above-reported results, we apply the following procedure to standardise the individual viability measures. 

1. For each plate, we define two standard values: 

    - $V_c$ is the median viability of the 8 cell controls (uninfected cells)
    - $V_v$ is the median viability of the 6 virus controls (infected untreated cells)
    
    These two values are deliberately estimated with the median measurement of the control replicate, in order to avoid the effect of outliers as denoted for the virus control of plate 17. 

2. A **relative viability index** $v_r$ is computed for each treatment as follows.

    $$v_r = \frac{v - V_c}{V_v - V_c} \cdot 100$$

    - $v_r$ provides a viability measurement on a scale where 0 corresponds to the median of infected untreated cells, and 100 to the median of uninfected cells. 
    - Note that $V_c$ values lower than 0 denote treatments with a lower viability than the untreated virus infection. This might result from a cytotoxic effect of the drug, or from a plate bias.
    - $V_c$ values can in principle also take values higher than 100, denoting a highly efficient treatment. 

```{r relative_viability}
#### Compute relative viability ####

## Plate-wise virus control
vcMed <- as.vector(by(data = inhibTable[wellType == "virusCtl", "viability"], 
                               INDICES = inhibTable[wellType == "virusCtl", "Plate"], 
                               FUN = median))
names(vcMed) <- 1:nbPlates

## Plate-wise cell control
ccMed <- as.vector(by(data = inhibTable[wellType == "cellCtl", "viability"], 
                               INDICES = inhibTable[wellType == "cellCtl", "Plate"], 
                               FUN = median))
names(ccMed) <- 1:nbPlates

## Relative viability
inhibTable$vcMed <- vcMed[inhibTable$Plate]
inhibTable$ccMed <- ccMed[inhibTable$Plate]
inhibTable$Vr <- 100 * (inhibTable$viability - inhibTable$vcMed) / 
  (inhibTable$ccMed - inhibTable$vcMed)

```

### Relative viability boxplots

```{r boxplots_per_plate_Vr, fig.width=7, fig.height=10, out.width="80%", fig.cap="Distribution of relative viability (Vr) values per plate"}

#### Boxplots of relative viability per plate ####

## Box plot per plate and well type
boxplot(Vr ~ Plate + wellType, 
        main = "Relative viability",
        data = inhibTable, 
        las = 1, col = plateColor, 
        xlab = "Vr", 
        cex.axis = 0.5, cex = 0.5,
        horizontal = TRUE)
abline(v = seq(from = 0, to = max(inhibTable$Vr), by = 5), col = "#EEEEEE", lty = "dashed")
abline(v = seq(from = 0, to = max(inhibTable$Vr), by = 25), col = "grey")
legend("topright", legend = names(plateColor), 
       title = "Plate", fill = plateColor, cex = 0.8)

par(par.ori)

```

The box plots show that the relative viability already has a normalizing effect by positioning each treatment between the virus and cell control of its own plate.

- The virus controls are well regrouped in the range of smaller $v_r$ values  (the third quartiles all fall below 15, except for plate).
- The cell controls occupy the high range (their first quartile is higher than 80) and are quite compactly grouped around 100. 

However, we still observe a systematic plate effect in plates 11 to 19:

- their median is mich higher than for the plates 1 to 10;
- they also show a much wider inter-quartile rectangle, denoting a very high variance between all the viability measurements on this plate;
- this higher variance is even visible in the virus control (untreated infected cells), and it is thus unlikely that it results from the particular molecules sampled on this second half of the plates. 

We thus need a way to perform a between-plates standardisation of the variance. 

### Relative viability plots

```{r iqNormV_plot, fig.width=7, fig.height=12, out.width="80%", fig.cap="Values of the plate-wise relative viability index for all the tested molecules. Molecules are colored according to the plate number. A: virus control (infected untreated); B: treated cells; C: cell control (untreated cells); D: ranked values (all types)"}
yRange <- c(floor(min(inhibTable$Vr)), ceiling(max(inhibTable$Vr)))

par(mfrow = c(4,1))
plot(inhibTable[wellType == "virusCtl", "Vr"],
     main = "Virus control (infected, untreated)",
     xlab = "Replicates, sorted per plate",
     ylab = "relative viability",
     col = inhibTable[wellType == "virusCtl", "color"],
     ylim = yRange,
     xlim = c(0, (nbPlates * 6 * 1.05)),
     panel.first = c(abline(h = 0), 
                     abline(h = 100),
                     abline(h = seq(10,90, 20), lty = "dotted"),
                     abline(v = (1:19) * 6, col = "grey")
                     ),
     las = 1,
     cex = 0.5
     )
legend("topright", 
       legend = names(plateColor), 
       col = plateColor, pch = 1, 
       cex = 0.7)
plot(inhibTable[wellType == "treated", "Vr"],
     main = "Relative viability (Vr)",
     xlab = "Molecules",
     ylab = "relative viability",
     col = inhibTable[wellType == "treated", "color"],
     ylim = yRange,
     xlim = c(0, (nbPlates * 80 * 1.05)),
     panel.first = c(abline(h = 0), 
                     abline(h = 100),
                     abline(h = seq(10,90, 20), lty = "dotted"),
                     abline(v = (1:19) * 80, col = "grey")
                     ),
     las = 1,
     cex = 0.5
     )
legend("topright", 
       legend = names(plateColor), 
       col = plateColor, pch = 1, 
       cex = 0.7)
plot(inhibTable[wellType == "cellCtl", "Vr"],
     main = "Cell control (uninfected)",
     xlab = "Replicates, sorted per plate",
     ylab = "relative viability",
     col = inhibTable[wellType == "cellCtl", "color"],
     ylim = yRange,
     xlim = c(0, (nbPlates * 8 * 1.05)),
     panel.first = c(abline(h = 0), 
                     abline(h = 100),
                     abline(h = seq(10,90, 20), lty = "dotted"),
                     abline(v = (1:19) * 8, col = "grey")
                     ),
     las = 1,
     cex = 0.5
     )
legend("topright", 
       legend = names(plateColor), 
       col = plateColor, pch = 1, 
       cex = 0.7)
# names(supTable)
VrRank <- order(inhibTable$Vr, decreasing = TRUE)
plot(inhibTable[VrRank, "Vr"],
     main = "Ranked relative viability values",
     xlab = "Molecules (ranked by relative viability)",
     ylab = "relative viability",
     col = inhibTable[VrRank, "color"],
     cex = 0.5,
     panel.first = grid(),
     xlim = c(0, length(VrRank) * 1.05)
     )
legend("topright", 
       legend = names(plateColor), 
       col = plateColor, pch = 1, 
       cex = 0.4)
par(mfrow = c(1,1))

```



## Inter-quartile standardisation

### Plate-wise normalised viability

We perform a plate-wise normalisation with a centering on the median and a scaling to compensate for the plate-wise variance effect denoted above. To this purpose, we compute z-scores from the original value. 

- centering: substract an estimator of the plate-wise mean ;
- scaling: divide by an estimator of the plate-wise standard deviation ($\hat{\sigma_i}$)

$$z_{c,i} = \frac{V_c - \hat{\mu_i}}{\hat{\sigma_i}}$$
where 

- $V_c$ is the viability for molecule $c$;
- $\hat{\mu_i}$ is the estimate for the mean viability of all the treated cells in plate $i$;
- $\hat{\sigma_i}$ is the estimate for the standard deviation of all the treated cells in plate $i$;

In classical statistics, the estimators of centrality and dispersion are derived from the sample mean and standard deviation, respectively:

- the population mean is used as maximum likelihood estimator of the population: $\hat{\mu} = \bar{x}$
- the population standard deviation ($\sigma$) is estimated with the sample standard deviation, corrected for the systematic bias: $\hat{\sigma} = \sqrt{n/(n-1)} \cdot s$)

However, we must be careful because each plate supposedly contain a mixture of  inactive  (no inhibitory effect) and active (inhibitory) molecules. The previous histograms and box plots show that these inhibitory molecules appear as statistiacal outliers (with very high viability values) and would thus strongly bias the estimation of the background variance (the variance due to fluctuations in absence of treatment). 

One possibility would be to use the standard deviation of the virus control to this purpose, but this would leat to instable estimators, since they would be based on 6 points per plate. In addition, the boxplots show that the variance among treated cells is higher than the virus control, suggesting some generic effect of the treatments. 

Another strategy is to consider that the variance (and standard deviation) can be estimated from the bulk of treated cell viability measures themselves, and to use **robust estimators** of the central tendency (i.e. the plate-wise median) and dispersion (i.e. the plate-wise interquartile range).  


This approach relies on the assumption that, *in each plate*, the number of active molecule (statistical outliers). Since teach plate contains tests of 80 molecules, there are 19 molecules above the third quartile ($Q3$). However, it has to be noted that the plates were manufactured with some grouping of molecules of the same structural family.  It might thus happen that some plates contain more than 19 molecules having an inhibitory effect. Such a situation would result in a loss of sensitivity, since the presence of active molecules in the inter-quartile range would lead to over-estimate the dispersion. 

An alternative is to estimate the dispersion based on the range between the first quartile ($Q1$) and the median ($\tilde{x}$) of each plate. 

In summary, we compute robust estimators, in order to avoid the effect of outliers (in this case, the suspected outliers are the molecules having an actual inhibitory effect). To this purpose, we use:

- plate-wise median viability ($\tilde{v}$) to estimate the mean
- plate-wise standardised inter-quantile range (IQR) to estimate the standard deviation

```{r plate_wise_stat_treated}
#### Copute plate-wise statistics ####
statPerPlate <- data.frame(
  Plate = plateNumbers,
  TrMean = as.vector(by(
    data = inhibTable[wellType == "treated", "viability"], 
    INDICES = inhibTable[wellType == "treated", "Plate"], 
    FUN = mean)),
  TrSD = as.vector(by(
    data = inhibTable[wellType == "treated", "viability"], 
    INDICES = inhibTable[wellType == "treated", "Plate"], 
    FUN = sd)),
  TrMedian = as.vector(by(
    data = inhibTable[wellType == "treated", "viability"], 
    INDICES = inhibTable[wellType == "treated", "Plate"], 
    FUN = median)),
  VCMedian = as.vector(by(
    data = inhibTable[wellType == "virusCtl", "viability"], 
    INDICES = inhibTable[wellType == "virusCtl", "Plate"], 
    FUN = median)),
  CCMedian = as.vector(by(
    data = inhibTable[wellType == "cellCtl", "viability"], 
    INDICES = inhibTable[wellType == "cellCtl", "Plate"], 
    FUN = median)),
  TrMin = as.vector(by(    
    data = inhibTable[wellType == "treated", "viability"], 
    INDICES = inhibTable[wellType == "treated", "Plate"], 
    FUN = min)),
  TrMax = as.vector(by(
    data = inhibTable[wellType == "treated", "viability"], 
    INDICES = inhibTable[wellType == "treated", "Plate"], 
    FUN = max)),
  TrQ1 = as.vector(by(
    data = inhibTable[wellType == "treated", "viability"], 
    INDICES = inhibTable[wellType == "treated", "Plate"], 
    FUN = quantile, probs = 0.25)),
  TrQ3 = as.vector(by(
    data = inhibTable[wellType == "treated", "viability"], 
    INDICES = inhibTable[wellType == "treated", "Plate"], 
    FUN = quantile, probs = 0.75)),
  TrIQR = as.vector(by(    data = inhibTable[wellType == "treated", "viability"], 
    INDICES = inhibTable[wellType == "treated", "Plate"], 
    FUN = IQR))
)
rownames(statPerPlate) <- statPerPlate$Plate


```


We define a plate-wise scaling factor from the interquantile range, standardized by the inter-quartile range of a Gaussian distribution. 

$$S_i = \frac{Q3_N - Q1_N}{Q3_i - Q3_i} = \frac{`r round(digits=3, qnorm(0.75) - qnorm(0.25))`}{Q3_i - Q3_i}$$

Where $Q1$ and $Q3$ denote the first and third quartile, $N$ the Normal distribution, and $i$ is the plate number. 

The viability measures of each plate are then multiplied by the corresponding scaling factor to obtain standardized values, which will have the same inter-quartile range as the normal distribution. 

The table below indicates the plate-wise statistics and scaling factor. 

```{r scaling_factor}
## Compute the scaling factor as the difference between median and Q1
## standardised relative to the same difference in a normal distribution.
statPerPlate$scaling <- (qnorm(p = 0.5) - qnorm(p = 0.25)) / (statPerPlate$TrMedian - statPerPlate$TrQ1)

## Compute scaling factor based on the standardized inter-quartile range.
statPerPlate$scaling <- (qnorm(p = 0.75) - qnorm(p = 0.25)) / (statPerPlate$TrQ3 - statPerPlate$TrQ1) 

kable(statPerPlate, caption = "Plate-wise statistics of treated cells. Column prefixes: Tr = treated cells; CC = cell control (uninfected cells); VC = virus control (infected, untreated cells). ")

```



```{r plate_wise_iqNormV}
#### Compute plate-wise normalised viability ####

## Centering: substract the median
## Scaling: divide by IQR
## Standardise: multiply by IQR of the normal distribution
plate <- as.vector(inhibTable$Plate)
inhibTable$iqNormV <- (inhibTable$viability - statPerPlate[plate, "TrMedian"]) * statPerPlate[plate, "scaling"]
# IQR(inhibTable$iqNormV)
# IQR(rnorm(n = 1000000))

# normIQR <- 2 * (qnorm(p = 0.5) - qnorm(p = 0.25))
# normII <- normII * normIQR
# sd(normII)
# IQR(normII)



```



```{r iqNormV_stat}
### Descriptive statistics on the normalised viability ####
iqNormVstat <- data.frame(
  mean = mean(inhibTable$iqNormV),
  sd = sd(inhibTable$iqNormV),
  IQR = IQR(inhibTable$iqNormV),
  var = var(inhibTable$iqNormV),
  min = min(inhibTable$iqNormV),
  Q1 = as.vector(quantile(inhibTable$iqNormV, probs = 0.25)),
  median = median(inhibTable$iqNormV),
  Q3 = as.vector(quantile(inhibTable$iqNormV, probs = 0.75)),
  max = max(inhibTable$iqNormV)
)

kable(t(iqNormVstat), 
      col.names = "Stat", 
      caption = "Statistics of the plate-wise normalised viability")

```


### Histograms of inter-quartile standardised viability

The histogram of plate-wise normalised viability shows a clear improvement : the median is much closer to the mode than with the raw or log-transformed II values.

```{r iqNormV_distrib, fig.width=7, fig.height=5, out.width="60%", fig.cap="Distribution of the plate-wise normalised viability. Top: virus control (infected, untreated); middle: treated; bottom: cell control (untreated)"}
#### Histograms of normalised viability ####
histBreaks = seq(from = floor(min(inhibTable$iqNormV)), 
                 to = ceiling(max(inhibTable$iqNormV)), by = 0.1)

par(mfrow = c(3,1))
hist(inhibTable[wellType == "virusCtl", "iqNormV"], 
     main = "Virus control – IQR standardised viability",
     breaks = histBreaks, xlab = "Normalised viability", 
     col = "orange", border = "orange")
hist(inhibTable[wellType == "treated", "iqNormV"], 
     main = "Treated cells – IQR standardised viability",
     breaks = histBreaks, xlab = "Normalised viability", 
     col = "grey", border = "grey")
abline(v = mean(inhibTable[wellType == "treated", "iqNormV"]), col = "blue")
abline(v = median(inhibTable[wellType == "treated", "iqNormV"]), col = "darkgreen")
legend("topright", legend = c("mean", "median"),
       col = c("blue", "darkgreen"),
       lwd = 2)
hist(inhibTable[wellType == "cellCtl", "iqNormV"], 
     main = "Cell control (untreated) – IQR standardised viability",
     breaks = histBreaks, xlab = "Normalised viability", 
     col = "palegreen", border = "palegreen")
par(par.ori)
```


### Boxplots: inter-quartile standardised viability

```{r boxplots_per_plate_iqNormV, fig.width=7, fig.height=10, out.width="80%", fig.cap="Distribution of inter-quartile standardised viability (iqNormV) values per plate"}

#### Boxplots of relative viability per plate ####

## Box plot per plate and well type
boxplot(iqNormV ~ Plate + wellType, 
        main = "Inter-quartile standardized viability",
        data = inhibTable, 
        las = 1, col = plateColor, 
        xlab = "iqNormV", 
        cex.axis = 0.5, cex = 0.5,
        horizontal = TRUE)
abline(v = seq(from = 0, to = max(inhibTable$iqNormV), by = 1), col = "#EEEEEE", lty = "dashed")
abline(v = seq(from = 0, to = max(inhibTable$iqNormV), by = 5), col = "grey")
legend("topright", legend = names(plateColor), 
       title = "Plate", fill = plateColor, cex = 0.8)

par(par.ori)

```

The above boxplots show that the inter-quartile standardization efficiently corrects for the over-dispersion of the plates 11 to 19. However we may expect a lot of sensitivity for these plates. There are however still some weaknesses. 

- The vurus control show good properties: in absence of treatment, infected cells have sligtly negative values, except for 2 outliers in plate 17. 

- The cell control box plots show wide variation in their medians and dispersion: 

    - Uninfected cells (cell control)  have much lower values in some plates (plates 4 and 11-19) than in other ones. This is not expected, since these cells should by definition have the same viability values. 
    
    - Even for the plates where the cell controls have a high viability after IQR-based standardisation, there are strong between-plates variations. 

This standardisation seems thus efficient to correct the apparent over-dispersion of plates 11 to 19, and thereby reduce the rate of likely false positives, but the wide between-plate variability of the untreated cells suggest that the resulting z-scores should not be interpreted as indicators of viability.


### Dot plots: inter-quartile standardised viability

```{r iqNormV_ranked, fig.width=7, fig.height=12, out.width="80%", fig.cap="Values of the plate-wise normalised viability index for all the tested molecules. Molecules are colored according to the plate number. A: virus control (infected untreated); B: treated cells; C: cell control (untreated cells); D: ranked values (all types)"}
yRange <- c(floor(min(inhibTable$iqNormV)), ceiling(max(inhibTable$iqNormV)))

par(mfrow = c(4,1))
plot(inhibTable[wellType == "virusCtl", "iqNormV"],
     panel.first = grid(),
     main = "Virus control (infected, untreated)",
     xlab = "Replicates, sorted per plate",
     ylab = "iqNormV",
     ylim = yRange,
     col = inhibTable[wellType == "virusCtl", "color"],
     cex = 0.5, las = 1
     )
abline(h = 0)
legend("topright", 
       legend = names(plateColor), 
       col = plateColor, pch = 1, 
       cex = 0.7)
plot(inhibTable[wellType == "treated", "iqNormV"],
     panel.first = grid(),
     main = "Normalised viability (iqNormV)",
     xlab = "Molecules",
     ylab = "iqNormV",
     ylim = yRange,
     col = inhibTable[wellType == "treated", "color"],
     cex = 0.5, las = 1,
     xlim = c(0, length(inhibTable[wellType == "treated", "iqNormV"])*1.05)
     )
abline(h = 0)
legend("topright", 
       legend = names(plateColor), 
       col = plateColor, pch = 1, 
       cex = 0.7)
plot(inhibTable[wellType == "cellCtl", "iqNormV"],
     panel.first = grid(),
     main = "Cell control (uninfected)",
     xlab = "Replicates, sorted per plate",
     ylab = "iqNormV",
     ylim = yRange,
     col = inhibTable[wellType == "cellCtl", "color"],
     cex = 0.5, las = 1
     )
abline(h = 0)
legend("topright", 
       legend = names(plateColor), 
       col = plateColor, pch = 1, 
       cex = 0.7)
# names(supTable)
iqNormVrank <- order(inhibTable$iqNormV, decreasing = TRUE)
plot(inhibTable[iqNormVrank, "iqNormV"],
     main = "Ranked normalised viability values",
     xlab = "Molecules (ranked by iqNormV index)",
     ylab = "iqNormV",
     col = inhibTable[iqNormVrank, "color"],
     cex = 0.5, las = 1,
     panel.first = grid(),
     xlim = c(0, length(iqNormVrank) * 1.05)
     )
abline(h = 0)
legend("topright", 
       legend = names(plateColor), 
       col = plateColor, pch = 1, 
       cex = 0.4)
par(mfrow = c(1,1))

```


The plot of normalised viability values (top panel) clearly shows that the plate-wise normalisation suppressed the background bias. However it denotes a new problem: the cell controls show striking differences depending on the plates. Noticeably,they show very high values in plates 1 and 3, and very low values in plates 11 to 19, as well as in plate 4.

## Three-points normalisation with arbidol

So far we tried two types of plate-wise normalisation, with a specific drawback for teach of them. 

- relative viability ($V_r$) performs a

```{r}
#### Select arbidol as plate-wise milestone ####

# names(inhibTable)
arbidolPlates <- (inhibTable$Column == 12) & (inhibTable$Row %in% c("A", "B"))
inhibTable[arbidolPlates, "chemicalName"] <- "Arbidol"
inhibTable[arbidolPlates, c("ID", "chemicalName")]
# View(table(inhibTable$chemicalName))

```


## P-value computation

We compute the p-value as the upper tail of the normal distribution (rigth-side test) in order to detect significantly high values of the plate-wise normalised index.

```{r iqNormVpval}
#### Compute P-value for the inhibition index ####
inhibTable$p.value <- pnorm(inhibTable$iqNormV, mean = 0, sd = 1, lower.tail = FALSE)
inhibTable$log10Pval <- log10(inhibTable$p.value)
inhibTable$e.value <- inhibTable$p.value * sum(wellType == "treated")
inhibTable$padj <- NA
inhibTable[wellType == "treated", "padj"] <- 
  p.adjust(inhibTable[wellType == "treated", "p.value"], method = "fdr")
inhibTable$log10Padj <- log10(inhibTable$padj)


```

```{r iqNormVpval_histogram, fig.width=7, fig.height=5, out.width="60%", fig.cap="Histogram of the nominal (unadjusted) p-values derived from the plate-wise normalised inhibition index. "}
hist(inhibTable[wellType == "treated", "p.value"], 
     breaks = 20, 
     col = "grey",
     main = "P-value histogram after plate-wise normalisation",
     xlab = "Nominal P-value (unadjusted)",
     ylab = "Frequency")

## Estimate the proportion of tests under H0 and H1 
## following the method proposed by Storey-Tibshirani (2003)
# lambda <- 0.40
# table(inhibTable[wellType == "treated", "p.value"] > lambda)
# m0 <- sum(inhibTable[wellType == "treated", "p.value"] > lambda) / (1 - lambda)
# m1 <- sum(wellType == "treated") - m0
# print(m0)
# print(m1)
# 
```

```{r iqNormV_manhattan_plot, fig.width=7, fig.height=4, out.width="80%", fig.cap="Volcano plot. "}
#### Manhattan plot ####
plot(x = -inhibTable[wellType == "treated", "log10Padj"], 
     col = inhibTable[wellType == "treated", "color"],
     main = "Significance plot",
     xlab = "Relative viability",
     ylab = "Significance = -log10(Padj)",
     panel.first = c(
       abline(h = 0), 
       abline(h = seq(0, -min(inhibTable[wellType == "treated", "log10Padj"]), 20), lty = "dotted", col = "grey"),
       abline(v = (1:19) * 80, col = "grey")
     ),
     las = 1,
     cex = 0.5)
legend("topright", 
       legend = names(plateColor), 
       col = plateColor, pch = 1, 
       cex = 0.7)

```


```{r iqNormV_volcano_plot, fig.width=7, fig.height=7, out.width="60%", fig.cap="Volcano plot. "}
#### Volcano plot ####
plot(x = inhibTable[wellType == "treated", "Vr"],
     y = -inhibTable[wellType == "treated", "log10Padj"], 
     col = inhibTable[wellType == "treated", "color"],
     main = "Volcano plot",
     xlab = "Relative viability",
     ylab = "Significance = -log10(Padj)")
grid()

```


## Selection of candidate molecules

```{r iqNormV_candidates}

#### Select significant normalised II values ####
alpha <- 0.05

kable(table(inhibTable$padj < alpha))


# table(inhibTable$padj < alpha)
selected <- subset(inhibTable, inhibTable$padj < alpha)

## Sort by decreasing adjusted p-value
selected <- selected[order(selected$padj, decreasing = FALSE), ]
# kable(names(selected), row.names=TRUE)

## Print selected molecules
kable(selected[ , c(1:3, 5:7, 10, 12, 15)], 
      row.names = FALSE,
      digits = 4,
      caption = "Candidate moecules sorted by significance after plate-wise normalisation. ")


```




********************************************************************

# Analysis of Touret's original Inhibition Index (II)

## Inhibition index

The inhibition index is derived from the raw viability measurement in the following way. 



### Descriptive stats

```{r inhib_index_stat}
ii <- supTable$Inhibition.Index
iiStat <- list(
  mean = mean(ii),
  sd = sd(ii),
  var = var(ii),
  min = min(ii),
  Q1 = as.vector(quantile(ii, probs = 0.25)),
  median = median(ii),
  Q3 = as.vector(quantile(ii, probs = 0.75)),
  max = max(ii)
)

kable(t(as.data.frame.list(iiStat)), col.names = "Stat")

```


### Distribution

The distribution of inhibition index values is trongly asymmetrical. The mode is much lower than the mean and the median (robust estimator of central tendency). A normal fit will tuhs give a poor estimate of the p-values. 
```{r inhib_index_distribution, fig.width=7, fig.height=5, out.width="60%",  fig.cap="Distribution of the inhibition index"}

hist(supTable$Inhibition.Index, breaks = 100, col = "grey", border = "grey")
abline(v = iiStat$mean, col = "blue")
abline(v = iiStat$median, col = "darkgreen")

legend("topright", legend = c("mean", "median"),
       col = c("blue", "darkgreen"),
       lwd = 2)

```



## Normalisation

### Log transform

A classical method for normalisation is to take the log of the values. We first had to shift the data in order for all of them to take positive values. 


```{r ii_normalisation}

# fit.gamma <- fitdist(data = ii - iiStat$min + 1, distr = "gamma", method = "mge")
# summary(fit.gamma)
# 
# plot(fit.gamma)

#### Compute a normalised distribution from inhibition indices ####
iiPositive <- ii - iiStat$min + 1 ## shift the distrib to achieve non-negative numbers
logII <- log(iiPositive)

logIIStat <- list(
  mean = mean(logII),
  sd = sd(logII),
  var = var(logII),
  min = min(logII),
  Q1 = as.vector(quantile(logII, probs = 0.25)),
  median = median(logII),
  Q3 = as.vector(quantile(logII, probs = 0.75)),
  max = max(logII)
)

kable(t(as.data.frame.list(logIIStat)), col.names = "Stat", caption = "Parameters of the log-normalised inhibition index distribution")

```


However, even after log transformation the distribution remains highly asymmetrical, with a mode much smaller than the median and mean. 

```{r logII_distrib, fig.width=7, fig.height=5, out.width="60%", fig.cap="Distribution of the inhibition index"}
#### Histogram of log-normalised values ####
hist(logII, breaks = 100, col = "grey", border = "grey")
abline(v = mean(logII), col = "blue")
abline(v = median(logII), col = "darkgreen")

legend("topright", legend = c("mean", "median"),
       col = c("blue", "darkgreen"),
       lwd = 2)


```


## Evidence of a plate bias

### Ranked values

We plot the inhibition index values ordered by plate and position number (top) or ranked by decreasing value (bottom). In both cases, the color denotes the plate number. 


```{r inhib_index_ranked, fig.width=7, fig.height=10, out.width="60%", fig.cap="Values of the inhibition index for all the tested molecules. Molecules are colored according to the plate number. "}
par(mfrow = c(2,1))
plot(ii,
     panel.first = grid(),
     main = "Inhibition index values",
     xlab = "Molecules (ranked by inhibition index)",
     ylab = "Inhibition index",
     col = supTable$color,
     cex = 0.5,
     xlim = c(0, length(ii)*1.05)
     )
legend("topright", 
       legend = names(plateColor), 
       col = plateColor, pch = 1, 
       cex = 0.7)

sortedTable <- supTable[order(supTable$Inhibition.Index, decreasing = TRUE), ]
plot(sortedTable$Inhibition.Index,
     panel.first = grid(),
     main = "Ranked inhibition index values",
     xlab = "Molecules (ranked by inhibition index)",
     ylab = "Inhibition index",
     col = sortedTable$color,
     cex = 0.5,
     xlim = c(0, length(ii)*1.05)
     )
legend("topright", 
       legend = names(plateColor), 
       col = plateColor, pch = 1, 
       cex = 0.7)
par(mfrow = c(1, 1))

```


The molecule-wised colored plots of inhibition index suggest a plate-wise effect. 

## Plate-wise normalisation

We perform a plate-wise normalisation using robust estimators, in order to avoid the effect of outliers (in this case, the suspected outliers are the molecules having an actual inhibitory effect).

To this purpose, we use:
- plate-wise median to estimate the mean
- plate-wise standardised inter-quantile range (IQR) to estimate the standard deviation

```{r plate_wise_stat}
#### Copute plate-wise statistics ####
plateStat <- data.frame(
  plate = plateNumbers,
  mean = as.vector(by(data = supTable$Inhibition.Index, INDICES = supTable$plateNumber, FUN = mean)),
  sd = as.vector(by(data = supTable$Inhibition.Index, INDICES = supTable$plateNumber, FUN = sd)),
  median = as.vector(by(data = supTable$Inhibition.Index, INDICES = supTable$plateNumber, FUN = median)),
  min = as.vector(by(data = supTable$Inhibition.Index, INDICES = supTable$plateNumber, FUN = min)),
  max = as.vector(by(data = supTable$Inhibition.Index, INDICES = supTable$plateNumber, FUN = max)),
  IQR = as.vector(by(data = supTable$Inhibition.Index, INDICES = supTable$plateNumber, FUN = IQR))
)
rownames(plateStat) <- plateStat$plate

kable(plateStat, caption = "Plate-wise statistics")

```

```{r plate_wise_normalisation}

## Centering: substract the median
## Scaling: divide by IQR
## Standardise: multiply by IQR of the normal distribution
normII <- (supTable$Inhibition.Index - plateStat[supTable$plateNumber, "median"]) / plateStat[supTable$plateNumber, "IQR"]
# IQR(normII)
# IQR(rnorm(n = 1000000))

normIQR <- qnorm(p = 0.75) - qnorm(p = 0.25)
normII <- normII * normIQR
# sd(normII)
# IQR(normII)

supTable$normInhibIndex <- normII

```



```{r normIIStat}
### Descriptive statistics on the normalised Inhibition Index ####
normIIStat <- list(
  mean = mean(normII),
  sd = sd(normII),
  IQR = IQR(normII),
  var = var(normII),
  min = min(normII),
  Q1 = as.vector(quantile(normII, probs = 0.25)),
  median = median(normII),
  Q3 = as.vector(quantile(normII, probs = 0.75)),
  max = max(normII)
)

kable(t(as.data.frame.list(normIIStat)), col.names = "Stat", caption = "Statistics of the plate-wise normalised inhibition index")

```


The histogram of plate-wise normalised values shows a clear improvement : the median is much closer to the mode than with the raw or log-transformed II values.

```{r normII_distrib, fig.width=7, fig.height=5, out.width="60%", fig.cap="Distribution of the plate-wise normalised inhibition index"}

hist(normII, breaks = 100, col = "grey", border = "grey")
abline(v = mean(normII), col = "blue")
abline(v = median(normII), col = "darkgreen")

legend("topright", legend = c("mean", "median"),
       col = c("blue", "darkgreen"),
       lwd = 2)

```

### Normalised II plots

The plot of normalised II values (top panel) clearly shows that the plate-wise normalisation suppressed the background bias. 


```{r normII_ranked, fig.width=7, fig.height=10, out.width="60%", fig.cap="Values of the plate-wise normalised inhibition index for all the tested molecules. Molecules are colored according to the plate number. "}
par(mfrow = c(2,1))
plot(normII,
     panel.first = grid(),
     main = "Inhibition index values",
     xlab = "Molecules (ranked by inhibition index)",
     ylab = "Inhibition index",
     col = supTable$color,
     cex = 0.5,
     xlim = c(0, length(normII)*1.05)
     )
legend("topright", 
       legend = names(plateColor), 
       col = plateColor, pch = 1, 
       cex = 0.7)

# names(supTable)
normIIrank <- order(supTable$normInhibIndex, decreasing = TRUE)
plot(supTable[normIIrank, "normInhibIndex"],
     panel.first = grid(),
     main = "Ranked inhibition index values",
     xlab = "Molecules (ranked by inhibition index)",
     ylab = "Inhibition index",
     col = supTable[normIIrank, "color"],
     cex = 0.5,
     xlim = c(0, length(normII)*1.05)
     )
legend("topright", 
       legend = names(plateColor), 
       col = plateColor, pch = 1, 
       cex = 0.4)
par(mfrow = c(1,1))

```




## P-value computation

We compute the p-value as the upper tail of the normal distribution (rigth-side test) in order to detect significantly high values of the plate-wise normalised index.

```{r normIIpval}
#### Compute P-value for the inhibition index ####
supTable$p.value <- pnorm(normII, mean = 0, sd = 1, lower.tail = FALSE)
supTable$log10Pval <- log10(supTable$p.value)
supTable$e.value <- supTable$p.value * length(normII)
supTable$padj <- p.adjust(supTable$p.value, method = "fdr")
supTable$log10Padj <- log10(supTable$padj)
```

```{r pval_histogram, fig.width=7, fig.height=5, out.width="60%", fig.cap="Histogram of the nominal (unadjusted) p-values derived from the plate-wise normalised inhibition index. "}
hist(supTable$p.value, breaks = 20, 
     col = "grey",
     main = "P-value histogram after plate-wise normalisation",
     xlab = "Nominal P-value (unadjusted)",
     ylab = "Frequency")
```



```{r volcano_plot, fig.width=7, fig.height=7, out.width="60%", fig.cap="Volcano plot. "}
#### Volcano plot ####

plot(x = supTable$normInhibIndex,
     y = -supTable$log10Padj, 
     col = supTable$color,
     main = "Volcano plot",
     xlab = "Normalised inhibition index",
     ylab = "Significance = -log10(Padj)")
grid()

```


## Selection of candidate molecules

```{r candidated}

#### Select significant normalised II values ####
alpha <- 0.05
# table(supTable$padj < alpha)
selected <- subset(supTable, supTable$padj < alpha)

## Sort by decreasing adjusted p-value
selected <- selected[order(selected$padj, decreasing = FALSE), ]
# kable(names(selected), row.names=TRUE)

## Print selected molecules
kable(selected[ , c(1:3, 5:7, 10, 12, 15)], 
      row.names = FALSE,
      digits = 4,
      caption = "Candidate moecules sorted by significance after plate-wise normalisation. ")


```



## Conclusions

I strongly recommend to use the plate-wise normalised inhibition index in order to select the candidate molecules. 

With an adjusted p-value of `r alpha`,  `r nrow(selected)` molecules are declared significant and could be considered as candidate for further characterisation. 




## Experimental design

- la manip consiste à faire un test colorimétrique

    - sur certains puits tout est négatif, sur d'autres tout est positiv

- mortalité des cellules

    - infectées non-traitées ("virus control")
    - 6 puits

- viabilité des cellules -> 100%

    - cellules non-infectées et non-traitées ("cell control")
    - 8 puits

- duplicat de traitement à l'arabidol 10µM

    - seuil par plaque
    - contrôle interne de la protection des cellules contre la mortalité viro-induite


- Valeurs de départ

    - mort cellulaire (moyenne sur 6 puits)
    - viabilité (moyenne sur 8 puits)
    - valeur du composé (monoplicat) : même concentration de 10µM par composé

Indice d'inhibition: 

$$V = A / (D + A)$$



$$II = $$

On cherche des molécules inhibitrices avec l'EC50 aux alentours de 5µM -> la concentration standard de 10µM on espère se trouver au début du plateau. 

## A faire

- comparer les listes de composés avant / après normalisation par plaque
- boxplot ou violin par plaque avant / après
- standardisation des valeurs de viabilité par la médiane
- distribution de valeurs plaque par plaque --> vérifier si certaines plaques ont l'air d'avoir plus de 20 cibles (percentile75)


- Contrôles intra-plaques
    - utiliser médiane plutôt que moyenne ?

- Valeurs négatives: 

    - fluctuations expérimentales ?
    - mortalité induite par le virus + la molécule ?
    
- Marquer sur les graphiques les valeurs de l'arbidol (contrôle interne en duplicat)


- boxplot des contrôles par plaque: 

    - cell viability
    - viral 


